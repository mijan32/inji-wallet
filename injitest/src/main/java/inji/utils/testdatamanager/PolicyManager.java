package inji.utils.testdatamanager;

import inji.models.Policy;

import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;

import static io.mosip.testrig.apirig.utils.AdminTestUtil.autoGeneratedIDValueCache;

public class PolicyManager {

    private static final BlockingQueue<Policy> availablePolicies = new LinkedBlockingQueue<>();

    static {
        for (int i = 1; i <= 3; i++) {
            availablePolicies.add(new Policy(
                    autoGeneratedIDValueCache.get("SunBirdR_CreatePolicy_NOAUTH_Valid_Smoke_POLICY" + i + "_Sid_POLICY"),
                    autoGeneratedIDValueCache.get("SunBirdR_CreatePolicy_NOAUTH_Valid_Smoke_POLICY" + i + "_Sid_NAME"),
                    autoGeneratedIDValueCache.get("SunBirdR_CreatePolicy_NOAUTH_Valid_Smoke_POLICY" + i + "_Sid_DOB")
            ));
        }
    }

    //Sample data, data can be passed in this way as well
//    static {
//        availablePolicies.add(new Policy("1234567", "Aman Shahi", "2025-07-29"));
//        availablePolicies.add(new Policy("12345678", "Aman Shahi", "2025-07-29"));
//        availablePolicies.add(new Policy("123456789", "Aman Shahi", "2025-07-29"));
//    }

    public static Policy acquirePolicy() throws InterruptedException {
        return availablePolicies.take(); // waits if none available
    }

    public static void releasePolicy(Policy policy) {
        availablePolicies.offer(policy); // returns policy to the pool
    }

    public static Policy acquirePolicyWithTimeout(long timeoutSeconds) throws InterruptedException {
        return availablePolicies.poll(timeoutSeconds, TimeUnit.SECONDS);
    }
}